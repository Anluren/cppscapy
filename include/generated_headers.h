#pragma once
// Generated by HDL Compiler
// Do not edit manually

#include <cstdint>
#include <vector>
#include <bitset>
#include <string>
#include <type_traits>

namespace cppscapy::dsl {

// Base class for all generated headers
class HeaderBase {
public:
    virtual ~HeaderBase() = default;
    
    virtual std::vector<uint8_t> to_bytes() const = 0;
    virtual bool from_bytes(const std::vector<uint8_t>& data) = 0;
    virtual size_t size_bits() const = 0;
    virtual size_t size_bytes() const { return (size_bits() + 7) / 8; }
    virtual bool is_valid() const = 0;
    virtual void update_computed_fields() = 0;
};

// Bit field manipulation utilities
template<typename T>
class BitField {
public:
    BitField(std::vector<uint8_t>& data, size_t bit_offset, size_t bit_width)
        : data_(data), bit_offset_(bit_offset), bit_width_(bit_width) {}
    
    T get() const {
        T value = 0;
        for (size_t i = 0; i < bit_width_; ++i) {
            size_t byte_idx = (bit_offset_ + i) / 8;
            size_t bit_idx = (bit_offset_ + i) % 8;
            
            if (byte_idx < data_.size()) {
                uint8_t bit = (data_[byte_idx] >> (7 - bit_idx)) & 1;
                value |= (static_cast<T>(bit) << (bit_width_ - 1 - i));
            }
        }
        return value;
    }
    
    void set(T value) {
        // Ensure data vector is large enough
        size_t required_bytes = (bit_offset_ + bit_width_ + 7) / 8;
        if (data_.size() < required_bytes) {
            data_.resize(required_bytes, 0);
        }
        
        for (size_t i = 0; i < bit_width_; ++i) {
            size_t byte_idx = (bit_offset_ + i) / 8;
            size_t bit_idx = (bit_offset_ + i) % 8;
            
            uint8_t bit = (value >> (bit_width_ - 1 - i)) & 1;
            
            // Clear the bit first
            data_[byte_idx] &= ~(1 << (7 - bit_idx));
            // Set the bit if needed
            data_[byte_idx] |= (bit << (7 - bit_idx));
        }
    }
    
    operator T() const { return get(); }
    BitField& operator=(T value) { set(value); return *this; }
    
private:
    std::vector<uint8_t>& data_;
    size_t bit_offset_;
    size_t bit_width_;
};

// Generated enum: EtherType
enum class EtherType : uint16_t {
    IPv4 = 0x0800,
    IPv6 = 0x86DD,
    ARP = 0x0806,
    MPLS = 0x8847,
    VLAN = 0x8100,
};

// Generated enum: IPProtocol
enum class IPProtocol : uint8_t {
    ICMP = 1,
    TCP = 6,
    UDP = 17,
    OSPF = 89,
};

// Generated from DSL: header EthernetHeader
class EthernetHeader : public HeaderBase {
public:
    EthernetHeader() : data_(14, 0) {}
    
    // dst_mac field (48 bits)
    uint64_t dst_mac() const {
        return BitField<uint64_t>(const_cast<std::vector<uint8_t>&>(data_), 0, 48).get();
    }
    void set_dst_mac(uint64_t value) {
        BitField<uint64_t>(data_, 0, 48).set(value);
    }
    
    // src_mac field (48 bits)
    uint64_t src_mac() const {
        return BitField<uint64_t>(const_cast<std::vector<uint8_t>&>(data_), 48, 48).get();
    }
    void set_src_mac(uint64_t value) {
        BitField<uint64_t>(data_, 48, 48).set(value);
    }
    
    // ethertype field (16 bits)
    EtherType ethertype() const {
        return static_cast<EtherType>(BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 96, 16).get());
    }
    void set_ethertype(EtherType value) {
        BitField<uint16_t>(data_, 96, 16).set(static_cast<uint16_t>(value));
    }
    
    // HeaderBase implementation
    std::vector<uint8_t> to_bytes() const override { return data_; }
    
    bool from_bytes(const std::vector<uint8_t>& data) override {
        if (data.size() < 14) return false;
        data_ = data;
        data_.resize(14);
        return true;
    }
    
    size_t size_bits() const override { return 112; }
    bool is_valid() const override { return data_.size() == 14; }
    
    void update_computed_fields() override {
    }
    
private:
    std::vector<uint8_t> data_;
};

// Generated from DSL: header IPv4Header
class IPv4Header : public HeaderBase {
public:
    IPv4Header() : data_(20, 0) {}
    
    // version field (4 bits)
    uint8_t version() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 0, 4).get();
    }
    void set_version(uint8_t value) {
        BitField<uint8_t>(data_, 0, 4).set(value);
    }
    
    // ihl field (4 bits)
    uint8_t ihl() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 4, 4).get();
    }
    void set_ihl(uint8_t value) {
        BitField<uint8_t>(data_, 4, 4).set(value);
    }
    
    // tos field (8 bits)
    uint8_t tos() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 8, 8).get();
    }
    void set_tos(uint8_t value) {
        BitField<uint8_t>(data_, 8, 8).set(value);
    }
    
    // total_length field (16 bits)
    uint16_t total_length() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 16, 16).get();
    }
    void set_total_length(uint16_t value) {
        BitField<uint16_t>(data_, 16, 16).set(value);
    }
    
    // identification field (16 bits)
    uint16_t identification() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 32, 16).get();
    }
    void set_identification(uint16_t value) {
        BitField<uint16_t>(data_, 32, 16).set(value);
    }
    
    // reserved field (1 bits)
    uint8_t reserved() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 48, 1).get();
    }
    void set_reserved(uint8_t value) {
        BitField<uint8_t>(data_, 48, 1).set(value);
    }
    
    // dont_fragment field (1 bits)
    uint8_t dont_fragment() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 49, 1).get();
    }
    void set_dont_fragment(uint8_t value) {
        BitField<uint8_t>(data_, 49, 1).set(value);
    }
    
    // more_fragments field (1 bits)
    uint8_t more_fragments() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 50, 1).get();
    }
    void set_more_fragments(uint8_t value) {
        BitField<uint8_t>(data_, 50, 1).set(value);
    }
    
    // fragment_offset field (13 bits)
    uint16_t fragment_offset() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 51, 13).get();
    }
    void set_fragment_offset(uint16_t value) {
        BitField<uint16_t>(data_, 51, 13).set(value);
    }
    
    // ttl field (8 bits)
    uint8_t ttl() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 64, 8).get();
    }
    void set_ttl(uint8_t value) {
        BitField<uint8_t>(data_, 64, 8).set(value);
    }
    
    // protocol field (8 bits)
    IPProtocol protocol() const {
        return static_cast<IPProtocol>(BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 72, 8).get());
    }
    void set_protocol(IPProtocol value) {
        BitField<uint8_t>(data_, 72, 8).set(static_cast<uint8_t>(value));
    }
    
    // header_checksum field (16 bits)
    uint16_t header_checksum() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 80, 16).get();
    }
    void set_header_checksum(uint16_t value) {
        BitField<uint16_t>(data_, 80, 16).set(value);
    }
    
    // src_ip field (32 bits)
    uint32_t src_ip() const {
        return BitField<uint32_t>(const_cast<std::vector<uint8_t>&>(data_), 96, 32).get();
    }
    void set_src_ip(uint32_t value) {
        BitField<uint32_t>(data_, 96, 32).set(value);
    }
    
    // dst_ip field (32 bits)
    uint32_t dst_ip() const {
        return BitField<uint32_t>(const_cast<std::vector<uint8_t>&>(data_), 128, 32).get();
    }
    void set_dst_ip(uint32_t value) {
        BitField<uint32_t>(data_, 128, 32).set(value);
    }
    
    // HeaderBase implementation
    std::vector<uint8_t> to_bytes() const override { return data_; }
    
    bool from_bytes(const std::vector<uint8_t>& data) override {
        if (data.size() < 20) return false;
        data_ = data;
        data_.resize(20);
        return true;
    }
    
    size_t size_bits() const override { return 160; }
    bool is_valid() const override { return data_.size() == 20; }
    
    void update_computed_fields() override {
    }
    
private:
    std::vector<uint8_t> data_;
};

// Generated from DSL: header UDPHeader
class UDPHeader : public HeaderBase {
public:
    UDPHeader() : data_(8, 0) {}
    
    // src_port field (16 bits)
    uint16_t src_port() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 0, 16).get();
    }
    void set_src_port(uint16_t value) {
        BitField<uint16_t>(data_, 0, 16).set(value);
    }
    
    // dst_port field (16 bits)
    uint16_t dst_port() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 16, 16).get();
    }
    void set_dst_port(uint16_t value) {
        BitField<uint16_t>(data_, 16, 16).set(value);
    }
    
    // length field (16 bits)
    uint16_t length() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 32, 16).get();
    }
    void set_length(uint16_t value) {
        BitField<uint16_t>(data_, 32, 16).set(value);
    }
    
    // checksum field (16 bits)
    uint16_t checksum() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 48, 16).get();
    }
    void set_checksum(uint16_t value) {
        BitField<uint16_t>(data_, 48, 16).set(value);
    }
    
    // HeaderBase implementation
    std::vector<uint8_t> to_bytes() const override { return data_; }
    
    bool from_bytes(const std::vector<uint8_t>& data) override {
        if (data.size() < 8) return false;
        data_ = data;
        data_.resize(8);
        return true;
    }
    
    size_t size_bits() const override { return 64; }
    bool is_valid() const override { return data_.size() == 8; }
    
    void update_computed_fields() override {
        // Update length field
        // TODO: Implement length calculation
        // Update checksum field
        // TODO: Implement checksum calculation
    }
    
private:
    std::vector<uint8_t> data_;
};

// Generated from DSL: header TCPHeader
class TCPHeader : public HeaderBase {
public:
    TCPHeader() : data_(20, 0) {}
    
    // src_port field (16 bits)
    uint16_t src_port() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 0, 16).get();
    }
    void set_src_port(uint16_t value) {
        BitField<uint16_t>(data_, 0, 16).set(value);
    }
    
    // dst_port field (16 bits)
    uint16_t dst_port() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 16, 16).get();
    }
    void set_dst_port(uint16_t value) {
        BitField<uint16_t>(data_, 16, 16).set(value);
    }
    
    // seq_num field (32 bits)
    uint32_t seq_num() const {
        return BitField<uint32_t>(const_cast<std::vector<uint8_t>&>(data_), 32, 32).get();
    }
    void set_seq_num(uint32_t value) {
        BitField<uint32_t>(data_, 32, 32).set(value);
    }
    
    // ack_num field (32 bits)
    uint32_t ack_num() const {
        return BitField<uint32_t>(const_cast<std::vector<uint8_t>&>(data_), 64, 32).get();
    }
    void set_ack_num(uint32_t value) {
        BitField<uint32_t>(data_, 64, 32).set(value);
    }
    
    // data_offset field (4 bits)
    uint8_t data_offset() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 96, 4).get();
    }
    void set_data_offset(uint8_t value) {
        BitField<uint8_t>(data_, 96, 4).set(value);
    }
    
    // reserved field (3 bits)
    uint8_t reserved() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 100, 3).get();
    }
    void set_reserved(uint8_t value) {
        BitField<uint8_t>(data_, 100, 3).set(value);
    }
    
    // flag_ns field (1 bits)
    uint8_t flag_ns() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 103, 1).get();
    }
    void set_flag_ns(uint8_t value) {
        BitField<uint8_t>(data_, 103, 1).set(value);
    }
    
    // flag_cwr field (1 bits)
    uint8_t flag_cwr() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 104, 1).get();
    }
    void set_flag_cwr(uint8_t value) {
        BitField<uint8_t>(data_, 104, 1).set(value);
    }
    
    // flag_ece field (1 bits)
    uint8_t flag_ece() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 105, 1).get();
    }
    void set_flag_ece(uint8_t value) {
        BitField<uint8_t>(data_, 105, 1).set(value);
    }
    
    // flag_urg field (1 bits)
    uint8_t flag_urg() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 106, 1).get();
    }
    void set_flag_urg(uint8_t value) {
        BitField<uint8_t>(data_, 106, 1).set(value);
    }
    
    // flag_ack field (1 bits)
    uint8_t flag_ack() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 107, 1).get();
    }
    void set_flag_ack(uint8_t value) {
        BitField<uint8_t>(data_, 107, 1).set(value);
    }
    
    // flag_psh field (1 bits)
    uint8_t flag_psh() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 108, 1).get();
    }
    void set_flag_psh(uint8_t value) {
        BitField<uint8_t>(data_, 108, 1).set(value);
    }
    
    // flag_rst field (1 bits)
    uint8_t flag_rst() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 109, 1).get();
    }
    void set_flag_rst(uint8_t value) {
        BitField<uint8_t>(data_, 109, 1).set(value);
    }
    
    // flag_syn field (1 bits)
    uint8_t flag_syn() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 110, 1).get();
    }
    void set_flag_syn(uint8_t value) {
        BitField<uint8_t>(data_, 110, 1).set(value);
    }
    
    // flag_fin field (1 bits)
    uint8_t flag_fin() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 111, 1).get();
    }
    void set_flag_fin(uint8_t value) {
        BitField<uint8_t>(data_, 111, 1).set(value);
    }
    
    // window_size field (16 bits)
    uint16_t window_size() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 112, 16).get();
    }
    void set_window_size(uint16_t value) {
        BitField<uint16_t>(data_, 112, 16).set(value);
    }
    
    // checksum field (16 bits)
    uint16_t checksum() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 128, 16).get();
    }
    void set_checksum(uint16_t value) {
        BitField<uint16_t>(data_, 128, 16).set(value);
    }
    
    // urgent_ptr field (16 bits)
    uint16_t urgent_ptr() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 144, 16).get();
    }
    void set_urgent_ptr(uint16_t value) {
        BitField<uint16_t>(data_, 144, 16).set(value);
    }
    
    // HeaderBase implementation
    std::vector<uint8_t> to_bytes() const override { return data_; }
    
    bool from_bytes(const std::vector<uint8_t>& data) override {
        if (data.size() < 20) return false;
        data_ = data;
        data_.resize(20);
        return true;
    }
    
    size_t size_bits() const override { return 160; }
    bool is_valid() const override { return data_.size() == 20; }
    
    void update_computed_fields() override {
        // Update checksum field
        // TODO: Implement checksum calculation
    }
    
private:
    std::vector<uint8_t> data_;
};

// Generated from DSL: header ICMPHeader
class ICMPHeader : public HeaderBase {
public:
    ICMPHeader() : data_(8, 0) {}
    
    // type field (8 bits)
    uint8_t type() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 0, 8).get();
    }
    void set_type(uint8_t value) {
        BitField<uint8_t>(data_, 0, 8).set(value);
    }
    
    // code field (8 bits)
    uint8_t code() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 8, 8).get();
    }
    void set_code(uint8_t value) {
        BitField<uint8_t>(data_, 8, 8).set(value);
    }
    
    // checksum field (16 bits)
    uint16_t checksum() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 16, 16).get();
    }
    void set_checksum(uint16_t value) {
        BitField<uint16_t>(data_, 16, 16).set(value);
    }
    
    // identifier field (16 bits)
    uint16_t identifier() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 32, 16).get();
    }
    void set_identifier(uint16_t value) {
        BitField<uint16_t>(data_, 32, 16).set(value);
    }
    
    // sequence field (16 bits)
    uint16_t sequence() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 48, 16).get();
    }
    void set_sequence(uint16_t value) {
        BitField<uint16_t>(data_, 48, 16).set(value);
    }
    
    // HeaderBase implementation
    std::vector<uint8_t> to_bytes() const override { return data_; }
    
    bool from_bytes(const std::vector<uint8_t>& data) override {
        if (data.size() < 8) return false;
        data_ = data;
        data_.resize(8);
        return true;
    }
    
    size_t size_bits() const override { return 64; }
    bool is_valid() const override { return data_.size() == 8; }
    
    void update_computed_fields() override {
        // Update checksum field
        // TODO: Implement checksum calculation
    }
    
private:
    std::vector<uint8_t> data_;
};

// Generated from DSL: header MPLSHeader
class MPLSHeader : public HeaderBase {
public:
    MPLSHeader() : data_(4, 0) {}
    
    // label field (20 bits)
    uint32_t label() const {
        return BitField<uint32_t>(const_cast<std::vector<uint8_t>&>(data_), 0, 20).get();
    }
    void set_label(uint32_t value) {
        BitField<uint32_t>(data_, 0, 20).set(value);
    }
    
    // traffic_class field (3 bits)
    uint8_t traffic_class() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 20, 3).get();
    }
    void set_traffic_class(uint8_t value) {
        BitField<uint8_t>(data_, 20, 3).set(value);
    }
    
    // bottom_of_stack field (1 bits)
    uint8_t bottom_of_stack() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 23, 1).get();
    }
    void set_bottom_of_stack(uint8_t value) {
        BitField<uint8_t>(data_, 23, 1).set(value);
    }
    
    // ttl field (8 bits)
    uint8_t ttl() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 24, 8).get();
    }
    void set_ttl(uint8_t value) {
        BitField<uint8_t>(data_, 24, 8).set(value);
    }
    
    // HeaderBase implementation
    std::vector<uint8_t> to_bytes() const override { return data_; }
    
    bool from_bytes(const std::vector<uint8_t>& data) override {
        if (data.size() < 4) return false;
        data_ = data;
        data_.resize(4);
        return true;
    }
    
    size_t size_bits() const override { return 32; }
    bool is_valid() const override { return data_.size() == 4; }
    
    void update_computed_fields() override {
    }
    
private:
    std::vector<uint8_t> data_;
};

// Generated from DSL: header VLANHeader
class VLANHeader : public HeaderBase {
public:
    VLANHeader() : data_(4, 0) {}
    
    // tpid field (16 bits)
    uint16_t tpid() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 0, 16).get();
    }
    void set_tpid(uint16_t value) {
        BitField<uint16_t>(data_, 0, 16).set(value);
    }
    
    // priority field (3 bits)
    uint8_t priority() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 16, 3).get();
    }
    void set_priority(uint8_t value) {
        BitField<uint8_t>(data_, 16, 3).set(value);
    }
    
    // cfi field (1 bits)
    uint8_t cfi() const {
        return BitField<uint8_t>(const_cast<std::vector<uint8_t>&>(data_), 19, 1).get();
    }
    void set_cfi(uint8_t value) {
        BitField<uint8_t>(data_, 19, 1).set(value);
    }
    
    // vlan_id field (12 bits)
    uint16_t vlan_id() const {
        return BitField<uint16_t>(const_cast<std::vector<uint8_t>&>(data_), 20, 12).get();
    }
    void set_vlan_id(uint16_t value) {
        BitField<uint16_t>(data_, 20, 12).set(value);
    }
    
    // HeaderBase implementation
    std::vector<uint8_t> to_bytes() const override { return data_; }
    
    bool from_bytes(const std::vector<uint8_t>& data) override {
        if (data.size() < 4) return false;
        data_ = data;
        data_.resize(4);
        return true;
    }
    
    size_t size_bits() const override { return 32; }
    bool is_valid() const override { return data_.size() == 4; }
    
    void update_computed_fields() override {
    }
    
private:
    std::vector<uint8_t> data_;
};


} // namespace cppscapy::dsl